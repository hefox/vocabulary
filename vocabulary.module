<?php

//include('vocabulary.taxonomy_menu.inc');

function vocabulary_menu() {
  $items['taxonomy/%taxonomy_vocabulary'] = array(
    'title callback' => 'taxonomy_admin_vocabulary_title_callback',
    'title arguments' => array(1),
    'page callback' => 'vocabulary_page',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'vocabulary.pages.inc',
    'type' => MENU_CALLBACK,
  );
  
  $items['taxonomy/%taxonomy_vocabulary/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $path = drupal_get_path('module', 'taxonomy');
  $items['taxonomy/%taxonomy_vocabulary/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_form_vocabulary', 1),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'taxonomy.admin.inc',
    'file path' => $path,
    'weight' => 5,
  );
 $items['taxonomy/%taxonomy_vocabulary/list'] = array(
    'title' => 'List',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_overview_terms', 1),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_TASK,
    'file path' => $path,
    'file' => 'taxonomy.admin.inc',
    'weight' => 10,

  );
 $items['taxonomy/%taxonomy_vocabulary/add'] = array(
    'title' => 'Add term',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('taxonomy_form_term', array(), 1),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'taxonomy.admin.inc',
    'file path' => $path,
  );
  return $items;
}


function vocabulary_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  if (arg(0) == 'taxonomy' && arg(2)=='edit') $form['#submit'][] =  'vocabulary_taxonomy_form_vocabulary_direct';
  field_attach_form('taxonomy_vocabulary', $form['#vocabulary'] , $form, $form_state);
}

function vocabulary_taxonomy_form_vocabulary($form, &$form_state) {
  $form_state['redirect'] = 'taxonomy/'.$form_state['values']['vid'];
  return;
}

function vocabulary_taxonomy_vocabulary_update($vocabulary){
  field_attach_update('taxonomy_vocabulary',$vocabulary);
}
function vocabulary_taxonomy_vocabulary_insert($vocabulary){
  field_attach_insert('taxonomy_vocabulary',$vocabulary);
}

function taxonomy_vocabulary_view($vocabulary, $view_mode = 'full') {
  field_attach_prepare_view('taxonomy_vocabulary', array($vocabulary->vid => $vocabulary), $view_mode);
  entity_prepare_view('taxonomy_vocabulary', array($vocabulary->vid => $vocabulary));

  $build = array(
    '#theme' => 'taxonomy_vocabulary',
    '#vocabulary' => $vocabulary,
    '#view_mode' => $view_mode,
  );

  $build += field_attach_view('taxonomy_vocabulary', $vocabulary, $view_mode);

  return $build;
}


function taxonomy_term_view_multiple($terms, $view_mode = 'teaser', $weight = 0) {
  field_attach_prepare_view('taxonomy_term', $terms, $view_mode);
  entity_prepare_view('taxonomy_term', $terms);
  $build = array();
  foreach ($terms as $term) {
    $build['terms'][$term->tid] = taxonomy_term_view($term, $view_mode);
    $build['terms'][$term->tid]['#weight'] = $weight;
    $weight++;
  }
  $build['terms']['#sorted'] = TRUE;
  return $build;
}


function vocabulary_entity_info_alter(&$entity_info)  {
  $entity_info['taxonomy_term']['view modes']['teaser']['label'] = t('Teaser');
  $entity_info['taxonomy_vocabulary']['fieldable'] = TRUE;
  /* Making vocalaries fieldable*/
  $entity_info['taxonomy_vocabulary']['bundles']['taxonomy_vocabulary']['label'] = t('Vocabulary');
  $entity_info['taxonomy_vocabulary']['bundles']['taxonomy_vocabulary']['admin']['path'] = 'admin/structure/taxonomy';
  $entity_info['taxonomy_vocabulary']['bundles']['taxonomy_vocabulary']['admin']['access arguments'] =  array('administer taxonomy');
  
  $entity_info['taxonomy_vocabulary']['view modes']['full']['label'] = t('Full');
}

/**
 * Implements hook_theme().
 */
function vocabulary_theme() {
  return array(
    'taxonomy_vocabulary' => array(
      'render element' => 'elements',
      'template' => 'taxonomy-vocabulary',
    ),
  );
}

function template_preprocess_taxonomy_vocabulary(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['vocabulary'] = $variables['elements']['#vocabulary'];
  $vocabulary = $variables['vocabulary'];

  $variables['vocabulary_url']  = url('taxonomy/' . $vocabulary->vid);
  $variables['vocabulary_name'] = check_plain($vocabulary->name);
  $variables['page']      = taxonomy_vocabulary_is_page($vocabulary);

  // Flatten the term object's member fields.
  $variables = array_merge((array)$vocabulary, $variables);

  // Helpful $content variable for templates.
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // field_attach_preprocess() overwrites the $[field_name] variables with the
  // values of the field in the language that was selected for display, instead
  // of the raw values in $term->[field_name], which contain all values in all
  // languages.
  field_attach_preprocess('taxonomy_vocabulary', $vocabulary, $variables['content'], $variables);
  // Gather classes.
  $variables['classes_array'][] = 'vocabulary-' . $vocabulary->machine_name;

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'taxonomy-vocabulary__' . $vocabulary->machine_name;
}

function taxonomy_vocabulary_is_page($vocabulary) {
  $page_vocabulary = menu_get_object('taxonomy_vocabulary', 1);
  return (!empty($page_vocabulary) ? $page_vocabulary->vid == $vocabulary->vid : FALSE);
}


/* token stuff */
/*
 * Implementation of hook_token_values
 

function vocabulary_token_values($type, $object = NULL) {

  $values = array();

  switch ($type) {
    case 'vocabulary':
      $values['vid'] = $object->vid;
      $values['vocab'] = check_plain($object->name);
      $values['vocab-raw'] = $object->name;
      break;
  }
  return $values;
}
/*
 * Implementation of hook_token_list
 
function vocabulary_token_list($type = 'all') {
  $tokens = array();
    if ($type == 'vocabulary' || $type == 'all') {
      $tokens['vocabulary']['vid'] = t('Vocabulary vid.');
      $tokens['vocabulary']['vocab-raw'] = t('Raw vocabulary name.');
      $tokens['vocabulary']['vocab'] = t('Vocabulary name.');
    }

  return $tokens;
}
/*
 * Pathauto stuff
 *
/*
 * Implementation of hook_pathauto
 *
function vocabulary_pathauto($op) {
  switch ($op) {
    case 'settings':
      $settings = array();
      $settings['module'] = 'vocabulary';
      $settings['token_type'] = 'vocabulary';
      $settings['groupheader'] = t('Vocabulary path settings');
      $settings['patterndefault'] = t('category/[vocab-raw]');
      $patterns = token_get_list('vocabulary');
      foreach ($patterns as $type => $pattern_set) {
        if ($type != 'global') {
          foreach ($pattern_set as $pattern => $description) {
            $settings['placeholders']['['. $pattern .']'] = $description;
          }
        }
      }
      $settings['supportsfeeds'] = '0/feed';
      $settings['bulkname'] = t('Bulk generate aliases for vocabularies that are not aliased');
      $settings['bulkdescr'] = t('Generate aliases for all existing vocabularies which do not already have aliases.');

      return (object) $settings;
    default:
      break;
  }
}


/**
 * Generate aliases for all nodes without aliases.
 *
function vocabulary_pathauto_bulkupdate() {
  // From all node types, only attempt to update those with patterns
  // If there's a default pattern we assume all types might be updated.
  $pattern = trim(variable_get('pathauto_vocabulary_pattern', '')) ;
  if (!$pattern) return;
  $vocabularies =  taxonomy_get_vocabularies();
  $placeholders = array();
  $count = 0;
  foreach($vocabularies as $vocabulary) {
    $placeholders = pathauto_get_placeholders('vocabulary', $vocabulary);
    if (pathauto_create_alias('vocabulary', 'bulkupdate', $placeholders, "taxonomy/$vocabulary->vid", $vocabulary->vid)) {
      $count++;
    }
   } 

  drupal_set_message(format_plural($count,
    'Bulk generation of vocabularies completed, one alias generated.',
    'Bulk generation of vocabularies completed, @count aliases generated.'));
}

/**
 * Implementation of hook_taxonomy().
 *
function vocabulary_taxonomy($op, $type, $object = NULL) {
  switch ($type) {
    case 'vocabulary':
      switch ($op) {
        case 'insert':
        case 'update':
          _pathauto_include();
          // Use the category info to automatically create an alias
          $vocabulary = (object) $object;
          if ($vocabulary->name) {
            $placeholders = pathauto_get_placeholders('vocabulary', $vocabulary);
            pathauto_create_alias('vocabulary', $op, $placeholders, "taxonomy/$vocabulary->vid", $vocabulary->vid);
          }

          break;
        case 'delete':
          // If the category is deleted, remove the path aliases
          $vocabulary = (object) $object;
          path_set_alias('taxonomy/'. $vocabulary->vid);
          path_set_alias('taxonomy/'. $vocabulary->vid .'/0/feed');
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
}


/*
 * Ctools items removed as ctools does not have a d7 release yet.
 */